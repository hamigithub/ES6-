ES6 ->ECMA 标准
            ↓
            JS
            ↓
            ES7 ES8...
            ↓
            ES5.x
            ↓
            ECMA-262 -> ES1.0
            ------------------------------------
            ES2015
            ↓
            ES6->2015年6月发布
            ↓
            每年6月份，发布一个版本
            ↓
            2016年6月 发布 ES6.1    ES7    ES2016
            2017年6月 发布 ES6.2    ES8    ES2017
            -------------------------------------
            ESnext（下一代大变更的JS语言，需要改进一些语法的漏洞等）
            -------------------------------------
            任何人都可以向 标准委员会（TC39），要求更改语言标准
            ↓
            提案变成标准，经历5个阶段
            stage 0    展示阶段
            stage 1    征求意见阶段
            stage 2    草案阶段
            stage 3    候选阶段
            stage 4    定案阶段（标准）

            ↓
            babel 下一代 JavaScript 语法的编译器
            --------------------------
            https://github.com/tc39/ecma262（github上的ECMA组织，更新公告）
            -----------------------------------
            ↓
            ES6 支持：
            react，Vue，angularJS，angular
            ↓
            Chrome 对新的语法支持，速度还挺猛
            -----------------------------
            ES6 环境：
                 webpack 3.x 支持编译
                 traceur 转码器
            -----------------------------
            关于定义（声明）变量：
                        之前：var a = 12;
                              let a = 12;

                        作用域：
                                全局
                                函数作用域
                                块级作用域

                        let 相当于之前的 var
                        const 常量，只读，定义好了不能改变

                        let注意：
                                1、没有预解析、不存在变量提升
                                    在代码块内，只要let定义变量，在之前使用，都会报错
                                    先定义完了，再使用
                                2、同一个作用域里面，不能重复定义相同的变量
                                3、for循环，for循环()里面是一个作用域，可以理解为父级作用域
                                   接着后面的{}里面是另外一个作用域，可以理解为上面的子级作用域
                                   两个作用域都是独立的，之间或有父子的关系


             块级作用域：{
                            //块级作用域
                        }
                        {{{{...}}}}块级作用域嵌套
                        if(){}
                        for(){}
                        while(){}


             const：特性和let一样
                    const 定义变量不能修改

                    const 定义完变量，必须有值，不能后赋值，不能修改，也就是必须初始化值给它

                    Object.freeze(对象)可以完全冻结一个对象，使之完全只读。

                    const config={
                        host:
                        username:
                        password:
                        version:
                    }
                    config = false;


                  在没有块级作用域{}之前，我们是使用IIFE，自执行函数来模拟块级作用域的
                  (function(){
                        //TODO
                  })()
                  现在我们只需要这样写就可以了
                  {
                    //TODO
                  }

                  建议：
                        以后就用 let 不要再使用 var
                        const http = require('http');
            ==============================================
            解构赋值：
                    * 非常有用，特别在做数据交互 ajax 的时候

                    let [a, b, c] = [12, 5, 6];//解构赋值
                    注意：左右两边，结构格式要保持一致

                    解构一个json
                    // let {name, age, job} = json;//解构JSON
                        let {name, age, job} = {
                            name: 'hami',
                            age: 18,
                            job: '码畜'
                        };//等同于上面的json

                     let {name:n, age:g, job: a} = json;//job:a 冒号后的a是重定义json的属性名
                         console.log(n, g, a)//hami 18 码畜

            解构的时候可以给默认值/缺省值：
                    let [a,b,c='默认值']=['aaa','bbb'];

            let a = 12;
            let b = 5;

            提一下：解构也会用在 import
            import {a,b,c} from './mod'

            ===============================================================

            字符串模板：
            `` 字符串模板：
                        优点：可以随意换行
                        语法：`...${变量}...`

            ES5 中的字符串拼接，是要死人的。
            字符串连接
            let str = `这个人叫${name}，年龄是${age}岁`;

            关于字符串的一些东西：
            ES2016新增
                    字符串查找：
                            str.indexOf(要找的东西)  返回索引（位置），没找到返回-1
                            str.includes(要找的东西) 返回值 true/false

                            判断浏览器：
                            if (navigator.userAgent.includes('Chrome')) {
                                    alert('是Chrome')
                                } else {
                                    alert('不是Chrome')
                                }

            http://
            有时候有些需求：我们需要判断，字符串是否以谁开头.
            字符串是否以谁开头：
                    str.starWith(检测的东西)
            字符串是否以谁结尾；
                    str.endsWith(检测的东西)
                    （可以检测地址，检测文件等，比如，图片是否以.png结尾，网址是否以.com,.cn等结尾）



            ES7 新增
                    重复字符串：
                            str.repeat(次数)

            ES8 新增

                    字符串填充：
                    str.padStart(整个字符串长度，填充的东西) 往前填充
                    str.padEnd()往后填充
            用途暂未知(或可作为字符串拼接用)
                    str.padStart(str.length + padStr.length, padStr)

            ========================================================

            函数变化：
                1、函数的默认参数

                    function show2({x = 0, y = 0} = {}) {
                        //此处设置一个空的解构赋值
                        console.log(x, y)
                    }
                    show2();//0 0

                2、函数的参数，它默认是已经定义了，不能再在代码块内再使用
                    let ，const 再次声明。

                        function show(a = 18) {
                            let a = 101;//错误
                            console.log(a);
                        }

                        show();//a已经被定义过了 Identifier 'a' has already been declared

                扩展运算符/rest运算符：
                    ...
                    当剩余参数来用的时候，必须放在最后一个参数位置

                    展开数组

                    ...：

                        [1,2,3,4] -> ...[1,2,3,4] -> 1,2,3,4,5

                    ...:
                        1,2,3,4,5 -> ...1,2,3,4,5 -> [1,2,3,4,5]

                    剩余参数：必须放到参数队列的最后一位。


           箭头函数：
                    =>

                    let show = () => 1;
                    这种写法是很少用的：
                    () => return的东西；

                    这种写法就是带有语句的，经常用：
                    () => {
                        语句
                        return
                    }

                    注意的地方：
                        1、this问题，定义函数所在的对象，不再是ES5中运行时所在的对象了；
                        2、箭头函数里面没有arguments,需要使用"..."剩余参数运算符；
                        3、箭头函数不能当构造函数。
=========================================================================================
数组：
        ES5里面新增的一些东西

        循环：
             1、for
                    for(let i=0;i<arr.length;i++)
             2、while

        --------------------------------------------
        arr.forEach()//代替普通的for循环
            arr.forEach(function (val, index, arr) {
                console.log(val, index, arr);
            })
        --------------------------------------------
        arr.map()//非常有用，特别是在做数据交互的时候，“映射”
                正常情况下，需要配合 return 返回的是一个新的数组
                若是没有 return，它的功能就相当于forEach

                注意：平时只要用map，一定是要有return

                用途：
                    重新整理数据结构
                    [{title:"aaa"}] -> [(t:"aaa")]


        --------------------------------------------
        arr.filter()
        //过滤，过滤一些不合格的"元素"，如果回调函数返回true，就留下来

        --------------------------------------------
        arr.some()
        //类似查找，数组里面某一个元素符合条件，返回true
        --------------------------------------------
        arr.every()
        //数组里面的所有元素都要符合条件，才返回true
        --------------------------------------------

        以上循环可以接收两个参数
                arr.forEach/map...(循环回调函数，this指向谁)
        --------------------------------------------
        --------------------------------------------
        arr.reduce() //从左往右
                求数组的和、阶乘

        arr.reduceRight()//从右往左

ES2017新增一个运算符：**
        求幂
            ES5的方法：Math.pow(2,3)
            ES2017：2**3
        ---------------------------------------------
        for...of...：
        arr.keys()      数组下标
        arr.entries()   数组的某一项
            for (let val of arr) {
                console.log(val);
            }
=================================================================
扩展运算符：
        ...
        let arr=[1,2,3]
        let arr2=[...arr];
     等价于：
        let arr2=Array.from(arr);

Array.from():
        作用：把类数组（比如获取的一组HTML元素NodeList，arguments...）
        个人观点：只要具备 length 这个属性，就算是类数组，包括string、arguments、NodeList、json（如果转换的对象是json，则json的属性中必须带有length这个属性）等

Array.of():
        作用：把一组值，转换成数组
            let arr = Array.of('apple', 'banana', 'orange');
            console.log(arr);//(3) ["apple", "banana", "orange"]

arr.find():
        作用：查找，找出第一个符合条件的数组成员，如果没有找到，它就返回undefined
arr.findIndex():
        作用：找的是位置,也就是item所在的索引，如果没有找到，它就返回 -1
arr.fill()填充：
        作用：arr.fill(填充的东西，开始的位置，结束的位置);

在ES2016里面新增：

        arr.includes()
                str.includes()
==========================================================================================
对象：
        json

        对象简洁语法（相当有用）：

        ES5如下：
                let json={
                    a:1,
                    b:2,
                    showA:function(){
                        return this.a;
                    }
                    showB:function(){
                        return this.b;
                    }
                }
        ES6如下：
                let json={
                    a,
                    b,
                    showA(){//一定注意，不要用箭头函数
                        return this.a;
                    }
                    showB{
                        return this.b;
                    }
                }
        比如Vue.js中的：
        new Vuex.Store({
            state,
            mutation,
            types,
            actions
        }),
        new Vue({
            router,
            App,
            vuex
        })

Object.is()：
        用途：用来比较两个值是否相等
        Object.is('a','a')
        与等号操作符不同：
            ==
            ===
        Object.is(NaN,NaN);
        Object.is(+0,-0);

Object.assign()：//比较常见的需求
        Object.assign(目标对象, 目标对象1，目标对象2...);
            function ajax(options){//用户传
                //用户如果不传，就应该设置一个默认值
                let defaults={
                        type:'get',
                        header:
                        data:{}
                        ...
                };
                //根据assign的特性，重复的属性，后面的覆盖前面的，所以这里将默认的defaults放在前面
                //当用户传进来的options没有值的时候，才使用defaults的值补充
                let json = Object.assign({},defaults,options);
                ...
            }

            用途：
                    1：用来合并对象
                    2：合并参数，比如框架中经常使用
                    3：合并数组，不常用

ES2017引入：
    Object.keys();
    Object.entries();
    Object.values();

    解构写法：    let {keys, values, entries} = Object;


对象身上：计划在ES2018引入
        ...

==========================================================================================
promise：承诺，许诺

        作用：解决异步回调的问题

        传统方式，大部分用回调函数，事件驱动这种方式

        ajax(URL，()=>{//获取token
             ajax(url,()=>{//拿着token去获取用户信息
                    ajax(url,()=>{
                            //获取用户相关新闻
                    })
             })
        })

        语法：

        let promise = new Promise(function (resolve,reject) {
            //resolve，成功的时候调用
            //reject，失败的时候调用
        })

        promise.then(res=>{

        },err=>{

        })

        promise.catch(err=>{})

        常见的用法：

        new Promise().then(res=>{

        }).catch(err=>{

        })
---------------------------
        Promise.resolve('aaa') ：将现有的东西，转成一个promise对象，resolve状态，成功的状态
            等价于：
            new Promise(resolve => {
                resolve('aaa')
            });

        Promise.reject('aaa')：将现有的东西，转成一个promise对象，reject状态，失败的状态
            等价于：
            new Promise(reject => {
                reject('aaa')
            });
-------------------------
        Promise.all([p1,p2,p3])：把promise打包，扔到一个数组里面，打包完还是一个promise对象
        必须确保，所有的promise对象，都是resolve状态，都是成功的状态。

        Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。
        需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。

        Promise.race([p1,p2,p3])：
        顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。
        原理是挺简单的，但是在实际运用中还没有想到什么的使用场景会使用到。
        (用于和定时器绑定，可以测试一些接口的响应速度，分析用户的网络状况之类的，，比如将一个请求，和三秒后执行定时器 包装成promise 实例，然后加入 promise.race队列中， 当请求三秒还未响应时候，可以给用户一些提示， 或者是一些其他操作)

        用户登录->获取用户信息->
===================================================================================================

模块化：
    JS 不支持模块化
            比如 ruby require





