ES6 ->ECMA 标准
            ↓
            JS
            ↓
            ES7 ES8...
            ↓
            ES5.x
            ↓
            ECMA-262 -> ES1.0
            ------------------------------------
            ES2015
            ↓
            ES6->2015年6月发布
            ↓
            每年6月份，发布一个版本
            ↓
            2016年6月 发布 ES6.1    ES7    ES2016
            2017年6月 发布 ES6.2    ES8    ES2017
            -------------------------------------
            ESnext（下一代大变更的JS语言，需要改进一些语法的漏洞等）
            -------------------------------------
            任何人都可以向 标准委员会（TC39），要求更改语言标准
            ↓
            提案变成标准，经历5个阶段
            stage 0    展示阶段
            stage 1    征求意见阶段
            stage 2    草案阶段
            stage 3    候选阶段
            stage 4    定案阶段（标准）

            ↓
            babel 下一代 JavaScript 语法的编译器
            --------------------------
            https://github.com/tc39/ecma262（github上的ECMA组织，更新公告）
            -----------------------------------
            ↓
            ES6 支持：
            react，Vue，angularJS，angular
            ↓
            Chrome 对新的语法支持，速度还挺猛
            -----------------------------
            ES6 环境：
                 webpack 3.x 支持编译
                 traceur 转码器
            -----------------------------
            关于定义（声明）变量：
                        之前：var a = 12;
                              let a = 12;

                        作用域：
                                全局
                                函数作用域
                                块级作用域

                        let 相当于之前的 var
                        const 常量，只读，定义好了不能改变

                        let注意：
                                1、没有预解析、不存在变量提升
                                    在代码块内，只要let定义变量，在之前使用，都会报错
                                    先定义完了，再使用
                                2、同一个作用域里面，不能重复定义相同的变量
                                3、for循环，for循环()里面是一个作用域，可以理解为父级作用域
                                   接着后面的{}里面是另外一个作用域，可以理解为上面的子级作用域
                                   两个作用域都是独立的，之间或有父子的关系


             块级作用域：{
                            //块级作用域
                        }
                        {{{{...}}}}块级作用域嵌套
                        if(){}
                        for(){}
                        while(){}


             const：特性和let一样
                    const 定义变量不能修改

                    const 定义完变量，必须有值，不能后赋值，不能修改，也就是必须初始化值给它

                    Object.freeze(对象)可以完全冻结一个对象，使之完全只读。

                    const config={
                        host:
                        username:
                        password:
                        version:
                    }
                    config = false;


                  在没有块级作用域{}之前，我们是使用IIFE，自执行函数来模拟块级作用域的
                  (function(){
                        //TODO
                  })()
                  现在我们只需要这样写就可以了
                  {
                    //TODO
                  }

                  建议：
                        以后就用 let 不要再使用 var
                        const http = require('http');
            ==============================================
            解构赋值：
                    * 非常有用，特别在做数据交互 ajax 的时候

                    let [a, b, c] = [12, 5, 6];//解构赋值
                    注意：左右两边，结构格式要保持一致

                    解构一个json
                    // let {name, age, job} = json;//解构JSON
                        let {name, age, job} = {
                            name: 'hami',
                            age: 18,
                            job: '码畜'
                        };//等同于上面的json

                     let {name:n, age:g, job: a} = json;//job:a 冒号后的a是重定义json的属性名
                         console.log(n, g, a)//hami 18 码畜

            解构的时候可以给默认值/缺省值：
                    let [a,b,c='默认值']=['aaa','bbb'];

            let a = 12;
            let b = 5;

            提一下：解构也会用在 import
            import {a,b,c} from './mod'

            ===============================================================

            字符串模板：
            `` 字符串模板：
                        优点：可以随意换行
                        语法：`...${变量}...`

            ES5 中的字符串拼接，是要死人的。
            字符串连接
            let str = `这个人叫${name}，年龄是${age}岁`;

            关于字符串的一些东西：
            ES2016新增
                    字符串查找：
                            str.indexOf(要找的东西)  返回索引（位置），没找到返回-1
                            str.includes(要找的东西) 返回值 true/false

                            判断浏览器：
                            if (navigator.userAgent.includes('Chrome')) {
                                    alert('是Chrome')
                                } else {
                                    alert('不是Chrome')
                                }

            http://
            有时候有些需求：我们需要判断，字符串是否以谁开头.
            字符串是否以谁开头：
                    str.starWith(检测的东西)
            字符串是否以谁结尾；
                    str.endsWith(检测的东西)
                    （可以检测地址，检测文件等，比如，图片是否以.png结尾，网址是否以.com,.cn等结尾）



            ES7 新增
                    重复字符串：
                            str.repeat(次数)

            ES8 新增

                    字符串填充：
                    str.padStart(整个字符串长度，填充的东西) 往前填充
                    str.padEnd()往后填充
            用途暂未知(或可作为字符串拼接用)
                    str.padStart(str.length + padStr.length, padStr)

            ========================================================

            函数变化：
                1、函数的默认参数

                    function show2({x = 0, y = 0} = {}) {
                        //此处设置一个空的解构赋值
                        console.log(x, y)
                    }
                    show2();//0 0

                2、函数的参数，它默认是已经定义了，不能再在代码块内再使用
                    let ，const 再次声明。

                        function show(a = 18) {
                            let a = 101;//错误
                            console.log(a);
                        }

                        show();//a已经被定义过了 Identifier 'a' has already been declared

                扩展运算符/rest运算符：
                    ...
                    当剩余参数来用的时候，必须放在最后一个参数位置

                    展开数组

                    ...：

                        [1,2,3,4] -> ...[1,2,3,4] -> 1,2,3,4,5

                    ...:
                        1,2,3,4,5 -> ...1,2,3,4,5 -> [1,2,3,4,5]

                    剩余参数：必须放到参数队列的最后一位。


           箭头函数：
                    =>

                    let show = () => 1;
                    这种写法是很少用的：
                    () => return的东西；

                    这种写法就是带有语句的，经常用：
                    () => {
                        语句
                        return
                    }

                    注意的地方：
                        1、this问题，定义函数所在的对象，不再是ES5中运行时所在的对象了；
                        2、箭头函数里面没有arguments,需要使用"..."剩余参数运算符；
                        3、箭头函数不能当构造函数。
=========================================================================================




















